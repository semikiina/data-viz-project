<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>League Visualization Dashboard</title>
    <link rel="stylesheet" type="text/css" href="lib/parasol.css" />
    <script src="lib/d3.v5.min.js"></script>
    <script src="lib/parasol.standalone.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        padding: 20px;
      }
      .controls {
        margin-bottom: 25px;
        padding: 10px;
        border: 1px solid #ccc;
        width: 350px;
        border-radius: 6px;
        background: #fafafa;
      }
      .control-label {
        margin-top: 10px;
        font-weight: bold;
      }
      .sr-only { position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }
    </style>
  </head>
  <body class="container m-auto">
    <h1 class="text-xl font-medium">PCP Visualization Settings</h1>

    <div class="grid grid-cols-2 gap-4">
      <div class="card controls">
        <div class="control-label">Curve smoothness:</div>
        <input type="range" min="0" max="25" value="0" id="smoothness" />
        <div class="control-label">Bundling strength for clusters:</div>
        <input type="range" min="0" max="100" value="0" id="bundling" />
        <div class="control-label">Line opacity (alpha):</div>
        <input type="range" min="0" max="100" value="10" id="alpha" />
        <div style="display:flex; gap:8px; align-items:center; margin-top:10px;">
          <div style="flex:1">
            <div class="control-label">Color by:</div>
            <select id="color-by-select" style="padding:6px; border-radius:4px; border:1px solid #ccc; width:100%;">
              <option value="league">League</option>
              <option value="cluster">Cluster</option>
            </select>
          </div>
          <div style="width:140px">
            <div class="control-label">Total clusters:</div>
            <select id="cluster-count-select" style="padding:6px; border-radius:4px; border:1px solid #ccc; width:100%;">
              <!-- options will be generated by JS -->
            </select>
          </div>
        </div>
      </div>

      <!-- Heatmap -->
      <div class="w-full h-96" style="transform: translateY(-50px);">
        <div id="heatmap-header" class="flex items-center justify-start" style="margin-bottom:6px; gap:8px;">
          <h2 id="heatmap-title" class="text-lg font-semibold mr-3">Attribute Correlation Heatmap</h2>
          <div id="league-dropdown" style="position:relative;">
            <label style="margin-right:6px; font-weight:600;">Leagues:</label>
            <button id="league-dropdown-toggle" style="padding:4px 8px; border:1px solid #ccc; border-radius:4px; background:#fff; min-width:220px;">
              <span id="league-dropdown-label">All Leagues</span>
              <span style="float:right;">â–¾</span>
            </button>
            <div id="league-dropdown-menu" style="position:absolute; z-index:10; top:32px; left:0; width:280px; max-height:240px; overflow:auto; border:1px solid #ddd; border-radius:6px; background:#fff; box-shadow:0 2px 8px rgba(0,0,0,0.15); display:none; padding:8px;"></div>
          </div>
        </div>
        <div id="sr-announce" class="sr-only" aria-live="polite"></div>
        <div id="heatmap" class="w-full h-80"></div>
      </div>
    </div>

    <!-- Parallel Coordinates -->
    <div id="p0" class="parcoords w-full h-80" style="overflow-x: auto;"></div>

    <!-- Data Grid -->
    <div id="grid" class="slickgrid-container"></div>

    <script>
      // -------------------------------------------
      // LOAD CSV + BUILD EVERYTHING
      // -------------------------------------------
      d3.csv("data/leagues_data.csv").then(function (data) {
        // -------------------------------------------
        // CLEAN ATTRIBUTE FILTERING
        // -------------------------------------------
        const ignoreKeys = new Set([
          //"team_name",
          "team_fifa_api_id",
          "team_api_id",
          "league_name_id",
          "date",
          "buildUpPlaySpeedClass",
          "buildUpPlayDribblingClass",
          "buildUpPlayPassingClass",
          "chanceCreationShootingClass",
          "chanceCreationCrossingClass",
          "chanceCreationPassingClass",
          "defencePressureClass",
          "defenceAggressionClass",
          "defenceTeamWidthClass",
        ]);

        // Ordinal mappings for categorical attributes
        const ordinalMappings = {
          buildUpPlayPositioningClass: { 'Organised': 1, 'Free Form': 2 },
          chanceCreationPositioningClass: { 'Organised': 1, 'Free Form': 2 },
          defenceDefenderLineClass: { 'Cover': 1, 'Offside Trap': 2 }
        };
        
        // Reverse mappings for display (number -> label)
        const ordinalLabels = {};
        for (const key in ordinalMappings) {
          ordinalLabels[key] = {};
          for (const label in ordinalMappings[key]) {
            ordinalLabels[key][ordinalMappings[key][label]] = label;
          }
        }

        const filteredData = data.map((row) => {
          const newRow = {};
          // Add league_name first to ensure it's the leftmost column
          newRow["league_name"] = row["league_name"];
          newRow["team_name"] = row["team_name"]
          // Then add all other non-ignored keys
          for (const key in row) {
            if (!ignoreKeys.has(key) && key !== "league_name" && key !== "team_name") {
              // For ordinal attributes, store both numeric value and original label
              if (ordinalMappings[key]) {
                const val = row[key];
                newRow[key] = ordinalMappings[key][val] !== undefined ? ordinalMappings[key][val] : null;
                newRow[key + '_label'] = val; // Store original label
              } else {
                newRow[key] = row[key];
              }
            }
          }
          return newRow;
        });

        

        const firstColumn = "league_name";

        // Recompute clusterVariables now that ordinal _ord fields exist
        const clusterVariables = Object.keys(filteredData[0]).filter((key) =>
          !ignoreKeys.has(key) &&
          // include keys that have at least one numeric value in the filtered data
          filteredData.some((d) => d[key] !== null && d[key] !== undefined && d[key] !== "" && !isNaN(+d[key]))
        );

        // -------------------------------------------
        // PARASOL PARALLEL COORDINATES
        // -------------------------------------------
        // Explicitly order dimensions so `league_name` appears leftmost
        const dimensionsOrdered = [
          firstColumn,
          ...clusterVariables.filter((v) => v !== firstColumn),
        ];

        // current coloring mode (controls how PCP polylines are colored)
        let currentColorMode = 'league'; // 'league' or 'cluster'
        // current number of clusters (k)
        let currentClusterK = 12;
        // current alpha/opacity for PCP lines
        let currentAlpha = 0.1;
        // current smoothness value (0-1)
        let currentSmoothness = 0;
        // current bundling strength (0-1)
        let currentBundling = 0;
        // keep a reference to current data passed to Parasol
        let currentParasolData = null;

        // Apply coloring to a Parasol instance based on mode
        function applyColoring(psInstance, mode, dataForParasol) {
          if (!psInstance) return;
          const modeLower = (mode || 'league').toLowerCase();

          if (modeLower === 'league') {
            const leagues = Array.from(new Set((dataForParasol || psInstance.state.data).map(d => d.league_name)));
            const leagueColor = d3.scaleOrdinal().domain(leagues).range(d3.schemeCategory10);
            psInstance.color(d => leagueColor(d.league_name)).render();
          } else if (modeLower === 'cluster') {
            const data = dataForParasol || psInstance.state.data;
            const clusters = Array.from(new Set(data.map(d => d.cluster)));
            const clusterPalette = d3.scaleOrdinal().domain(clusters).range(d3.schemeTableau10);
            psInstance.color(d => clusterPalette(d.cluster)).render();
          }
        }

        // Initialize Parasol (wrap in function so we can recreate with filtered data)
        function initParasol(dataForParasol) {
          // clear previous containers to avoid duplicate renders
          const parcoordsEl = document.querySelector('.parcoords');
          if (parcoordsEl) parcoordsEl.innerHTML = '';
          const gridEl = document.querySelector('#grid');
          if (gridEl) gridEl.innerHTML = '';

          // build parasol instance. Only cluster if we have numeric vars available.
          const psBase = Parasol(dataForParasol)('.parcoords')
            .attachGrid({ container: '#grid' })
            .linked()
            .alpha(currentAlpha)
            .reorderable();

          // Determine which variables are numeric in the supplied data (exclude league/team)
          const keys = dataForParasol && dataForParasol.length ? Object.keys(dataForParasol[0]) : [];
          const numericVars = keys.filter(k => k !== 'league_name' && k !== 'team_name' && dataForParasol.some(d => !isNaN(+d[k])));

          let psLocal = psBase;
          if (numericVars.length > 0) {
            psLocal = psBase.cluster({ k: currentClusterK, vars: numericVars, hidden: false });
          }
          psLocal = psLocal.render();

          // Apply saved smoothness and bundling settings
          if (currentSmoothness > 0) {
            psLocal.smoothness(currentSmoothness);
          }
          if (currentBundling > 0) {
            psLocal.bundlingStrength(currentBundling).bundleDimension('cluster');
          }
          if (currentSmoothness > 0 || currentBundling > 0) {
            psLocal.render();
          }

          // Customize tick labels for ordinal attributes to show text instead of numbers
          setTimeout(() => {
            const parcoordsSvg = d3.select('.parcoords svg');
            if (!parcoordsSvg.empty()) {
              // Find all axis groups and their text elements
              parcoordsSvg.selectAll('.dimension').each(function() {
                const dimGroup = d3.select(this);
                const axisTitle = dimGroup.select('.label').text();

                // Check if this is an ordinal attribute
                if (ordinalLabels[axisTitle]) {
                  // Replace tick labels and hide intermediate numeric ticks
                  dimGroup.selectAll('.tick').each(function() {
                    const tick = d3.select(this);
                    const textEl = tick.select('text');
                    const numValue = parseFloat(textEl.text());
                    if (!isNaN(numValue)) {
                      const mapped = ordinalLabels[axisTitle][numValue];
                      if (mapped) {
                        textEl.text(mapped);
                      } else {
                        // Hide ticks that are not exactly the mapped ordinal values
                        tick.style('display', 'none');
                      }
                    }
                  });
                }
              });
            }
          }, 10);

          // ensure currentParasolData references latest (used by coloring control)
          currentParasolData = dataForParasol;

          // apply coloring according to current mode (league/cluster)
          applyColoring(psLocal, currentColorMode, dataForParasol);

          // If the provided data contains only a single league, hide the `league_name` axis
          const uniqueLeagues = Array.from(new Set(dataForParasol.map(d => d.league_name)));
          if (uniqueLeagues.length === 1) {
            // hide the league_name axis when only one league is present
            if (psLocal.hideAxes) {
              psLocal.hideAxes(['league_name']);
              psLocal.showAxes(['team_name']);
              psLocal.alpha(0.5).render();
            }
          } else {
            // ensure league_name is visible when multiple leagues are present
            if (psLocal.showAxes) {
              psLocal.showAxes(['league_name']);
              psLocal.hideAxes(['team_name']);
            } 
          }

          // (re)bind sliders: remove previous listeners first to avoid duplicates
          d3.select('#bundling').on('input', null);
          d3.select('#smoothness').on('input', null);
          d3.select('#alpha').on('input', null);

          // Helper function to reapply ordinal labels after render
          function reapplyOrdinalLabels() {
            setTimeout(() => {
              const parcoordsSvg = d3.select('.parcoords svg');
              if (!parcoordsSvg.empty()) {
                parcoordsSvg.selectAll('.dimension').each(function() {
                  const dimGroup = d3.select(this);
                  const axisTitle = dimGroup.select('.label').text();

                  if (ordinalLabels[axisTitle]) {
                    dimGroup.selectAll('.tick').each(function() {
                      const tick = d3.select(this);
                      const textEl = tick.select('text');
                      const numValue = parseFloat(textEl.text());
                      if (!isNaN(numValue)) {
                        const mapped = ordinalLabels[axisTitle][numValue];
                        if (mapped) {
                          textEl.text(mapped);
                        } else {
                          tick.style('display', 'none');
                        }
                      }
                    });
                  }
                });
              }
            }, 10);
          }

          d3.select('#bundling').on('input', function () {
            currentBundling = +this.value / 100;
            psLocal.bundlingStrength(currentBundling)
              .bundleDimension('cluster')
              .render();
            reapplyOrdinalLabels();
          });
          d3.select('#smoothness').on('input', function () {
            currentSmoothness = +this.value / 100;
            psLocal.smoothness(currentSmoothness).render();
            reapplyOrdinalLabels();
          });
          d3.select('#alpha').on('input', function () {
            currentAlpha = +this.value / 100;
            psLocal.alpha(currentAlpha).render();
            reapplyOrdinalLabels();
          });

          return psLocal;
        }

        function renderEmptyParasol() {
          const parcoordsEl = document.querySelector('.parcoords');
          if (parcoordsEl) parcoordsEl.innerHTML = '';
          const gridEl = document.querySelector('#grid');
          if (gridEl) gridEl.innerHTML = '';
          currentParasolData = [];
        }

        // create initial Parasol instance with only `league_name` (PCP starts empty)
        const initialOnlyLeagueData = filteredData.map(d => ({ league_name: d.league_name, team_name: d.team_name }));
        let ps = initParasol(initialOnlyLeagueData);

        // populate cluster-count-select with options and bind handler
        const clusterCountSelect = d3.select('#cluster-count-select');
        const clusterOptions = [3,4,5,6,7,8,9,10,12,15];
        clusterCountSelect.selectAll('option')
          .data(clusterOptions)
          .enter()
          .append('option')
          .attr('value', d => d)
          .text(d => d + ' clusters');
        clusterCountSelect.property('value', currentClusterK);
        clusterCountSelect.on('change', function() {
          const k = +this.value;
          if (!isNaN(k) && k > 1) {
            currentClusterK = k;
            const currentLeagues = Array.isArray(selectedLeagues) ? selectedLeagues : [];
            if (currentLeagues.length === 0) {
              renderEmptyParasol();
              return;
            }
            const leagueRows = filteredData.filter(d => currentLeagues.includes(d.league_name));
            const payload = leagueRows.map(d => {
              const obj = { league_name: d.league_name, team_name: d.team_name };
              selectedAttributes.forEach(a => { obj[a] = d[a]; });
              return obj;
            });
            ps = initParasol(payload);
          }
        });

        // selected attributes state (attributes chosen by clicking axis labels)
        let selectedAttributes = [];

        // Highlight or unhighlight axis labels based on selection state
        function updateAxisLabelHighlights() {
          const heatmapDiv = document.getElementById('heatmap');
          if (!heatmapDiv) return;

          // Find all SVG text elements in the heatmap (these are axis labels)
          const svgTexts = heatmapDiv.querySelectorAll('text');
          svgTexts.forEach(textEl => {
            const labelText = textEl.textContent.trim();
            const isSelected = selectedAttributes.indexOf(labelText) !== -1;
            const isAttribute = heatmapAttributes.indexOf(labelText) !== -1;

            // Only style attribute labels
            if (isAttribute) {
              if (isSelected) {
                textEl.style.fontWeight = 'bold';
                textEl.style.fill = '#d32f2f';
              } else {
                textEl.style.fontWeight = 'normal';
                textEl.style.fill = '#000';
              }
              textEl.style.cursor = 'pointer';
            }
          });
        }

        // Setup label clicking
        function setupLabelClickHandling() {
          const heatmapDiv = document.getElementById('heatmap');
          if (!heatmapDiv) return;

          // Add Plotly click handler for matrix cells
          heatmapDiv.on('plotly_click', function(data) {
            const point = data.points[0];
            if (point && point.x && point.y) {
              // Both x and y attributes are clicked together
              console.log('Cell clicked: x=', point.x, 'y=', point.y);
              toggleAttribute(point.x);
              toggleAttribute(point.y);
            }
          });

          // Find and mark the text elements as clickable after a short delay
          const svgTexts = heatmapDiv.querySelectorAll('text');
          svgTexts.forEach(textEl => {
            const labelText = textEl.textContent.trim();
            const isAttribute = heatmapAttributes.indexOf(labelText) !== -1;

            if (isAttribute) {
              // Make the text element pointer events work
              textEl.style.pointerEvents = 'auto';
              textEl.style.cursor = 'pointer';
              
              // Use pointer/mouse events instead of click
              textEl.addEventListener('pointerdown', function(e) {
                e.stopPropagation();
                e.preventDefault();
                console.log('Label clicked:', labelText);
                toggleAttribute(labelText);
              }, true); // Use capture phase
            }
          });
        }

        // Toggle attribute
        function toggleAttribute(attr) {
          if (!attr) return;
          const i = selectedAttributes.indexOf(attr);
          if (i === -1) selectedAttributes.push(attr);
          else selectedAttributes.splice(i, 1);
          console.log('Toggled:', attr, 'Selected attributes:', selectedAttributes);

          updateAxisLabelHighlights();
          rebuildParasolFromSelection();
        }

        function rebuildParasolFromSelection() {
          const currentLeagues = Array.isArray(selectedLeagues) ? selectedLeagues : [];
          if (currentLeagues.length === 0) {
            renderEmptyParasol();
            return;
          }
          const leagueRows = filteredData.filter(d => currentLeagues.includes(d.league_name));
          const payload = leagueRows.map(d => {
            const obj = { league_name: d.league_name, team_name: d.team_name };
            selectedAttributes.forEach(a => { obj[a] = d[a]; });
            return obj;
          });
          ps = initParasol(payload);
        }

        // -------------------------------------------
        // BUILD HEATMAP (Plotly)
        // -------------------------------------------
        // Heatmap: attributes vs attributes for a selected league
        const heatmapAttributes = [
          "buildUpPlaySpeed",
          "buildUpPlayDribbling",
          "buildUpPlayPassing",
          "buildUpPlayPositioningClass",
          "chanceCreationPassing",
          "chanceCreationCrossing",
          "chanceCreationShooting",
          "chanceCreationPositioningClass",
          "defencePressure",
          "defenceAggression",
          "defenceTeamWidth",
          "defenceDefenderLineClass"
        ];

        // Helper to compute mean for each attribute in a league
        function getLeagueAttributeMeans(leagueName) {
          const leagueRows = leagueName === 'All Leagues' ? filteredData : filteredData.filter((d) => d.league_name === leagueName);
          const means = {};
          heatmapAttributes.forEach((attr) => {
            const vals = leagueRows
              .map((d) => +d[attr])
              .filter((v) => !isNaN(v));
            means[attr] = d3.mean(vals);
          });
          return means;
        }



        function renderLeagueHeatmap(leagueSelection) {
          const selected = Array.isArray(leagueSelection) ? leagueSelection : [leagueSelection];
          if (selected.length === 0) {
            try { Plotly.purge('heatmap'); } catch (e) {}
            const hm = document.getElementById('heatmap');
            if (hm) hm.innerHTML = '<div style="padding:8px;color:#555;">No leagues selected.</div>';
            return;
          }
          // Clear any empty state message when rendering actual data
          const hm = document.getElementById('heatmap');
          if (hm) hm.innerHTML = '';
          
          const useAll = selected.includes('All Leagues');
          // Build correlation matrix (Pearson) for the selected leagues (or all leagues)
          const leagueRows = useAll ? filteredData : filteredData.filter((d) => selected.includes(d.league_name));

          // Extract arrays of numeric values (null where missing)
          const attrValues = heatmapAttributes.map((attr) =>
            leagueRows.map((d) => {
              const n = +d[attr];
              return isNaN(n) ? null : n;
            })
          );

          function pearson(xArr, yArr) {
            const pairsX = [];
            const pairsY = [];
            for (let i = 0; i < xArr.length; i++) {
              const x = xArr[i];
              const y = yArr[i];
              if (x !== null && y !== null) {
                pairsX.push(x);
                pairsY.push(y);
              }
            }
            const n = pairsX.length;
            if (n === 0) return 0;
            const meanX = d3.mean(pairsX);
            const meanY = d3.mean(pairsY);
            let num = 0,
              denomX = 0,
              denomY = 0;
            for (let i = 0; i < n; i++) {
              const dx = pairsX[i] - meanX;
              const dy = pairsY[i] - meanY;
              num += dx * dy;
              denomX += dx * dx;
              denomY += dy * dy;
            }
            const denom = Math.sqrt(denomX * denomY);
            if (denom === 0) return 0;
            return num / denom;
          }

          const matrix = heatmapAttributes.map((a, i) =>
            heatmapAttributes.map((b, j) => {
              if (i === j) return 1;
              return pearson(attrValues[i], attrValues[j]);
            })
          );

          // Clamp values to [-1, 1] and format
          const clamped = matrix.map((row) => row.map((v) => Math.max(-1, Math.min(1, v))));

          // Reverse y-axis order so attributes appear opposite
          const yAttrs = heatmapAttributes.slice().reverse();
          const zReordered = clamped.slice().reverse();
          const textReordered = zReordered.map((row) => row.map((v) => v.toFixed(2)));

            // Update page header (we keep a single title outside the Plotly canvas)
            document.getElementById('heatmap-title').textContent = `Attribute Correlation Heatmap`;

          Plotly.newPlot(
            "heatmap",
            [
              {
                z: zReordered,
                x: heatmapAttributes,
                y: yAttrs,
                type: "heatmap",
                colorscale: "RdBu",
                zmin: -1,
                zmax: 1,
                showscale: true,
                colorbar: { tickvals: [-1, -0.5, 0, 0.5, 1] },
                text: textReordered,
                texttemplate: "%{text}",
                hoverinfo: "text+z",
              },
            ],
            {
              // remove Plotly's built-in title to avoid duplicate titles
              width: 800,
              height: 480,
              margin: { l: 60, r: 120, t: 20, b: 160 },
              xaxis: { automargin: true, tickangle: -30, tickfont: { size: 10 } },
              yaxis: { automargin: true, tickfont: { size: 10 } },
            }
          );

          // Setup label clicking and restore highlights for selected attributes
          setupLabelClickHandling();
        }

        // A11y helpers for league dropdown
        function updateLeagueDropdownLabel() {
          const labelEl = document.getElementById('league-dropdown-label');
          if (!labelEl) return;
          if (selectedLeagues.length === leagues.length) labelEl.textContent = 'All leagues';
          else if (selectedLeagues.length === 0) labelEl.textContent = 'No leagues';
          else if (selectedLeagues.length === 1) labelEl.textContent = selectedLeagues[0];
          else labelEl.textContent = `${selectedLeagues.length} leagues selected`;
        }
        function announceSelection(msg) {
          const el = document.getElementById('sr-announce');
          if (el) el.textContent = msg;
        }
        function singleSelectLeague(leagueName) {
          selectedLeagues = [leagueName];
          d3.select('#league-dropdown-menu').selectAll('input.league-checkbox')
            .property('checked', d => d === leagueName);
          updateLeagueDropdownLabel();
          renderLeagueHeatmap(selectedLeagues);
          rebuildParasolFromSelection();
          announceSelection(leagueName + ' only');
          const menuEl = document.getElementById('league-dropdown-menu');
          if (menuEl) menuEl.style.display = 'none';
          updateAxisLabelHighlights();
        }
        function selectAllLeagues() {
          selectedLeagues = leagues.slice();
          d3.select('#league-dropdown-menu').selectAll('input.league-checkbox')
            .property('checked', true);
          updateLeagueDropdownLabel();
          renderLeagueHeatmap(selectedLeagues);
          rebuildParasolFromSelection();
          announceSelection('All leagues selected');
          updateAxisLabelHighlights();
        }
        function clearAllLeagues() {
          selectedLeagues = [];
          d3.select('#league-dropdown-menu').selectAll('input.league-checkbox')
            .property('checked', false);
          updateLeagueDropdownLabel();
          renderLeagueHeatmap(selectedLeagues);
          rebuildParasolFromSelection();
          announceSelection('No leagues selected');
          updateAxisLabelHighlights();
        }

        // Build custom league dropdown and render initial heatmap
        const leagues = Array.from(new Set(data.map((d) => d.league_name))).sort();
        let selectedLeagues = leagues.slice();
        updateLeagueDropdownLabel();
        const menu = d3.select('#league-dropdown-menu');
        
        // Add Select all / Clear all buttons
        const controlsDiv = menu.append('div')
          .style('display', 'flex')
          .style('gap', '6px')
          .style('margin-bottom', '8px')
          .style('padding-bottom', '8px')
          .style('border-bottom', '1px solid #ddd');
        
        controlsDiv.append('button')
          .text('Select all')
          .style('flex', '1')
          .style('padding', '4px 8px')
          .style('border', '1px solid #ccc')
          .style('border-radius', '4px')
          .style('background', '#f5f5f5')
          .style('cursor', 'pointer')
          .style('font-size', '12px')
          .on('click', function() {
            d3.event.stopPropagation();
            selectAllLeagues();
          });
        
        controlsDiv.append('button')
          .text('Clear all')
          .style('flex', '1')
          .style('padding', '4px 8px')
          .style('border', '1px solid #ccc')
          .style('border-radius', '4px')
          .style('background', '#f5f5f5')
          .style('cursor', 'pointer')
          .style('font-size', '12px')
          .on('click', function() {
            d3.event.stopPropagation();
            clearAllLeagues();
          });
        
        const items = menu.selectAll('div.league-item')
          .data(leagues)
          .enter()
          .append('div')
          .attr('class', 'league-item')
          .style('display', 'flex')
          .style('align-items', 'center')
          .style('gap', '8px')
          .style('padding', '4px 2px');
        items.append('input')
          .attr('type', 'checkbox')
          .attr('class', 'league-checkbox')
          .attr('aria-label', d => 'Select ' + d)
          .attr('id', d => 'lg-' + d.replace(/\s+/g, '-'))
          .property('checked', true)
          .on('click', function(d) { d3.event.stopPropagation(); })
          .on('change', function(d) {
            const value = d;
            const isChecked = this.checked;
            if (isChecked) {
              if (!selectedLeagues.includes(value)) selectedLeagues.push(value);
            } else {
              selectedLeagues = selectedLeagues.filter(l => l !== value);
            }
            updateLeagueDropdownLabel();
            announceSelection(
              selectedLeagues.length === 0 ? 'No leagues selected'
                : (selectedLeagues.length === leagues.length ? 'All leagues selected'
                : (selectedLeagues.length === 1 ? selectedLeagues[0] + ' selected' : (selectedLeagues.length + ' leagues selected')))
            );
            renderLeagueHeatmap(selectedLeagues);
            rebuildParasolFromSelection();
            updateAxisLabelHighlights();
          });
        items.append('span')
          .attr('class', 'league-text')
          .attr('role', 'button')
          .attr('tabindex', 0)
          .text(d => d)
          .style('cursor', 'pointer')
          .on('click', function(d) {
            d3.event.preventDefault();
            d3.event.stopPropagation();
            singleSelectLeague(d);
          })
          .on('keydown', function(d) {
            const e = d3.event;
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              e.stopPropagation();
              singleSelectLeague(d);
            }
          });

        // toggle open/close
        const toggleBtn = document.getElementById('league-dropdown-toggle');
        const menuEl = document.getElementById('league-dropdown-menu');
        toggleBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          const visible = menuEl.style.display === 'block';
          menuEl.style.display = visible ? 'none' : 'block';
        });
        document.addEventListener('click', function() { menuEl.style.display = 'none'; });

        // Ensure the PCP reflects the default league selection (but only with league_name until attributes selected)
        const initialLeagueData = filteredData;
        const initialParasolPayload = initialLeagueData.map(d => ({ league_name: d.league_name, team_name: d.team_name }));
        ps = initParasol(initialParasolPayload);

        // when league changes, re-render heatmap and rebuild PCP with filtered data
        // native select handler removed (replaced by custom dropdown)

        // color-by select: let user switch between 'league' and 'cluster'
        const colorBySelect = d3.select('#color-by-select');
        colorBySelect.property('value', currentColorMode);
        colorBySelect.on('change', function () {
          currentColorMode = this.value;
          applyColoring(ps, currentColorMode, currentParasolData);
        });

        // Initial render
        renderLeagueHeatmap(selectedLeagues);
      });
    </script>
    <!-- Run with: 
     python -m http.server 8000 
     http://localhost:8000/ -->
  </body>
</html>
